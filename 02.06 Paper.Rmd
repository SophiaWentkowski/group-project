---
title: "Stop, Slow, Go, how stops affect bike travel time"
output: html_document
date: "2023-05-26"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(mapview)
library(sf)
library(tmap)
```

#Abstract

#Introduction
Getting from A to B is a matter we humans have been dealing with since the day of age. From only being able to get around by foot, technological advances have made it possible to move with more sophisticated methods such as cars, trains or planes. However, to this day, non motorized means of transportation remain a part of our life, such as the bicycle. The prupolsion of bicycles is generated by the cyclist and hence requieres some form of strength and energy from the operator. Jan Burri, one of the authors, cycles to rugby training twice a week and wants to know the most efficient way on how to get to training.

This paper will in a first step give an overview of the used methodology, wheras the code of the different steps will be visible in the different chapters of the paper. The resluts will show where the cyclist stops and why these halts occur. 
Following the different trajectories will be split up into different segments which can then be cross-checked with oneanother. This way, the trajectory can be built from the different segments. This will allow to determine the most efficient trajectory. To finalize the evaluation, the most efficient determined trajectory by the authors will be compared with the trajectory suggested by Google maps to see, whether these are identical.


#Methods and materials
```{r}
posmo<-read_csv("posmo.csv") |> 
 st_as_sf(coords=c("lon_x", "lat_y"), crs=4326, remove=T) |> 
  st_transform(2056)

posmo$datetime <- as.POSIXct(posmo$datetime,  tz= "UTC")

posmo_coordinates <- st_coordinates(posmo)

posmo <- cbind(posmo, posmo_coordinates)

#cleaning the data
posmo <- posmo[posmo$transport_mode=="Bike",]

#traffic lights
lights <- read_sf("osm_traffic_lights.gpkg")
plot(lights)

mapview(lights)
```

```{r}
#Adding new convenience variables to identify trajectories
posmo <- posmo |> 
  mutate( traj = ((ifelse(is.na(user_id)== T, "BREAK", "COMBINE")))
          )
#currently twice in file, needed to index trajectories
rle_id <- function(vec) {
    x <- rle(vec)$lengths
    as.factor(rep(seq_along(x), times = x))
}

posmo <- posmo |>
    mutate(traj_id = rle_id(traj))

#visualizing it
posmo |> 
  ggplot(aes(X,Y))+
  geom_point(aes(color=traj_id))+ 
  facet_wrap(~traj_id)

#trajectory 19 seems to have combined two trajectries into one. An NA row is added between the two trajecotries that the rle_id can seperate them. 
test <- posmo |> 
  filter(traj_id==19)

row_index <- which(posmo$datetime == as.POSIXct("2023-04-27 20:42:23", tz="UTC"))
posmo <- posmo |> 
  add_row(.after= row_index)

posmo[row_index+1, "traj"] <- "BREAK"

posmo <- posmo |>
    mutate(traj_id = rle_id(traj))

#because of a stop at coop, trajectories 13 and 15 were split up. These will be recombined in the trajectory 15

posmo$traj_id <- ifelse(posmo$traj_id == 13, 15,posmo$traj_id)

# the same happend for traj_id 33 and 31. Will be comined in traj_id 31

posmo$traj_id <- ifelse(posmo$traj_id == 33, 31,posmo$traj_id)

#The break "trajectories" are not of interest and will be deleted and the real trajectories renumbered 
posmo <- subset(posmo, !grepl("BREAK",traj,ignore.case = T))

posmo <- posmo |>
    mutate(traj_id2 = rle_id(traj_id))

posmo |> 
  ggplot(aes(X,Y))+
  geom_point(aes(color=traj_id2))+
  facet_wrap(~traj_id2)
```

The definition of efficency for this paper is defined by two aspects: 
1. the smallest number of stops per trajectory
2. the shortest distance 

#Results

##Stops and roads


##Trajectories split into segments
```{r}
#To be able to compute euclidean distances by hand, we need the coordinates stored in separate columns. The function st_coordinates extracts the coordinates from our sf object. We can bind these coordinates back to our sf object using cbind


posmo_filter <- select(posmo,datetime, X, Y, traj_id2)

posmo_filter <- posmo_filter |> 
  rename(traj_id = traj_id2 )

ggplot(posmo_filter, aes(X,Y, color=datetime))+
  geom_point()

#segmentation
posmo_filter <- posmo_filter |> 
  mutate(steplength = sqrt((lead(X)-X)^2 +(lead(Y)-Y)^2))

posmo_filter <-posmo_filter |>
  group_by(traj_id) |> 
  mutate(
    n_plus1 = sqrt((lead(X,1)-X)^2 +(lead(Y,1)-Y)^2),
    n_plus2 = sqrt((lead(X,2)-X)^2 +(lead(Y,2)-Y)^2),
    n_minus1 = sqrt((lag(X,1)-X)^2 +(lag(Y,1)-Y)^2),
    n_minus2 = sqrt((lag(X,2)-X)^2 +(lag(Y,2)-Y)^2)
    )

#Static and moving
posmo_filter <- posmo_filter |> 
  rowwise() |> 
  mutate(
    stepMean =mean(c(n_minus1, n_minus2, n_plus1, n_plus2))
  ) |> 
      ungroup()

posmo_filter <- posmo_filter |> 
  group_by(traj_id) |> 
  mutate(
    traj_mean = mean(stepMean, na.rm = TRUE),
    static = stepMean < traj_mean
    ) 

#posmo_static <- posmo_filter |>
    #ungroup() |>
    #mutate(static = stepMean < mean(stepMean, na.rm = TRUE))

posmo_static <- posmo_filter |>    
    filter(static)   

#visualizing segment trajectories
posmo_filter |> 
  mutate(static =stepMean < mean(stepMean, na.rm =TRUE)) |> 
  ggplot(aes(X,Y))+
  geom_path()+
  geom_point(aes(color=static))+
  coord_fixed()

#indexing the trajectories
posmo_filter <- posmo_filter |>
    mutate(segment_id = rle_id(static))

#all of it 
posmo_filter |> 
  ggplot(aes(X,Y))+
  geom_point(aes(color=segment_id))+
  geom_path()+
  coord_fixed()

# only the moving data
posmo_filter |> 
  filter(!static) |> 
  ggplot(aes(X,Y))+
  geom_point(aes(color=segment_id))+
  coord_fixed()
```


```{r}
#needed? 

#Calculating the duration of intervals and grouping them by segment ID
posmo_filter <- posmo_filter |> 
  mutate(duration= datetime-lag(datetime))

posmo_filter |> 
  group_by(segment_id) |> 
  summarize( segment_duration= sum(duration))

# Now I want to cut out the segments which are shorter than 1min / 60s
delete<- posmo_filter |> 
  group_by(segment_id) |> 
  summarize( segment_duration= sum(duration)) |> 
  filter(segment_duration > 60) 

posmo_1min <- posmo_filter[(posmo_filter$segment_id %in% delete$segment_id),]

# Moving data which is longer than 1min

posmo_1min|> 
  filter(!static) |> 
  ggplot(aes(X,Y))+
  geom_point(aes(color=segment_id))+
  coord_fixed()

```

## Analyzing the differnt parts of the trip
```{r}
#Splitting the trajectory into different parts according to bottlenecks
A_part <- posmo_filter |> 
  filter(X <= 2682400) |> 
  filter(Y > 1245454.8177882368)

B_part <- posmo_filter |> 
  filter(X > 2682400) |> 
  filter(X <= 2683450) 

C_part <- posmo_filter |> 
  filter(X > 2683450) 

A_part |> 
  filter(static ==F) |> 
  ggplot(aes(X,Y))+
  geom_point(aes(color=segment_id))+
  geom_path()

A_part |> 
  filter(static ==F) |>
  ggplot(aes(X,Y))+
  geom_point(aes(color=traj_id))+ 
  facet_wrap(~traj_id)

A_part |> 
  ggplot(aes(X,Y))+
  #geom_point(aes(color=static))+
  geom_path(aes(color= traj_id))

# Want to count the number of stops per part per trajectory
A_stop <- A_part |>
  filter(static == T) |> 
  distinct(traj_id, segment_id) |> 
  group_by(traj_id) |> 
  summarize(Stops = n())

B_stop <- B_part |>
  filter(static == T) |> 
  distinct(traj_id, segment_id) |> 
  group_by(traj_id) |> 
  summarize(Stops = n())

C_stop <- C_part |>
  filter(static == T) |> 
  distinct(traj_id, segment_id) |> 
  group_by(traj_id) |> 
  summarize(Stops = n())


A_stop |> 
  ggplot(aes(traj_id, Stops))+
  geom_point()

#Want to know the length of each trajectory, I have to recompute this to know only the length of the moving segments
A_length<- A_part |> 
  filter(static==F) |> 
  group_by(traj_id) |> 
  mutate(distance = sqrt((lead(X,1)-X)^2 +(lead(Y,1)-Y)^2))|> 
  group_by(traj_id) |> 
  summarize(length = sum(distance, na.rm=T))

B_length<- B_part |> 
  filter(static==F) |> 
  group_by(traj_id) |> 
  mutate(distance = sqrt((lead(X,1)-X)^2 +(lead(Y,1)-Y)^2))|> 
  group_by(traj_id) |> 
  summarize(length = sum(distance, na.rm=T))

C_length<- C_part |> 
  filter(static==F) |> 
  group_by(traj_id) |> 
  mutate(distance = sqrt((lead(X,1)-X)^2 +(lead(Y,1)-Y)^2))|> 
  group_by(traj_id) |> 
  summarize(length = sum(distance, na.rm=T))

A_length |> 
  ggplot(aes(x=traj_id,y=length))+
  geom_point()
```

```{r}
#Checking for overlaps between the trajectories
 library(igraph)

A_part |> 
  group_by(traj_id) |> 
  summarise(do_union = FALSE) |> 
  st_cast("LINESTRING") -> A_part_lines


A_part_lines |> 
  st_buffer(50) -> A_part_lines_buff

myn <- nrow(A_part_lines_buff)
mymat <- matrix(nrow = myn, ncol = myn)

for (i in 1:myn) {
  for (j in 1:myn) {
    if (i == j) {
      mymat[i, j] <- NA
    } else {
      inter <- st_intersection(A_part_lines_buff[i, ], A_part_lines_buff[j, ])
      mymat[i, j] <- as.numeric(st_area(inter)) / as.numeric(st_area(A_part_lines_buff[i, ]))
    }
  }
}

overlaps <- mymat> 0.8
overlaps

traj_group <- graph_from_adjacency_matrix(overlaps, mode = "undirected", weighted = TRUE, diag = FALSE)
plot(traj_group)

group_ids <- clusters(traj_group)$membership

A_part$group_id<-group_ids

```


```




#Discussion

## Comparison

