---
title: "Stop, Slow, Go, how stops affect bike travel time"
output: html_document
date: "2023-05-26"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(mapview)
library(sf)
library(tmap)
```

#Abstract

#Introduction
Getting from A to B is a matter we humans have been dealing with since the day of age. From only being able to get around by foot, technological advances have made it possible to move with more sophisticated methods such as cars, trains or planes. However, to this day, non motorized means of transportation remain a part of our life, such as the bicycle. The prupolsion of bicycles is generated by the cyclist and hence requieres some form of strength and energy from the operator. Jan Burri, one of the authors, cycles to rugby training twice a week and wants to know the most efficient way on how to get to training.

This paper will in a first step give an overview of the used methodology, wheras the code of the different steps will be visible in the different chapters of the paper. The resluts will show where the cyclist stops and why these halts occur. 
Following the different trajectories will be split up into different segments which can then be cross-checked with oneanother. This way, the trajectory can be built from the different segments. This will allow to determine the most efficient trajectory. To finalize the evaluation, the most efficient determined trajectory by the authors will be compared with the trajectory suggested by Google maps to see, whether these are identical.


#Methods and materials
```{r}
posmo<-read_csv("posmo.csv") |> 
 st_as_sf(coords=c("lon_x", "lat_y"), crs=4326, remove=T) |> 
  st_transform(2056)

posmo$datetime <- as.POSIXct(posmo$datetime,  tz= "UTC")

posmo_coordinates <- st_coordinates(posmo)

posmo <- cbind(posmo, posmo_coordinates)

#cleaning the data
posmo <- posmo[posmo$transport_mode=="Bike",]

#traffic lights
lights <- read_sf("osm_traffic_lights.gpkg")
plot(lights)

mapview(lights)
```

```{r}
#Adding new convenience variables to identify trajectories
posmo <- posmo |> 
  mutate( traj = ((ifelse(is.na(user_id)== T, "BREAK", "COMBINE")))
          )
#currently twice in file, needed to index trajectories
rle_id <- function(vec) {
    x <- rle(vec)$lengths
    as.factor(rep(seq_along(x), times = x))
}

posmo <- posmo |>
    mutate(traj_id = rle_id(traj))

#visualizing it
posmo |> 
  ggplot(aes(X,Y))+
  geom_point(aes(color=traj_id))+ 
  facet_wrap(~traj_id)

#trajectory 19 seems to have combined two trajectries into one. An NA row is added between the two trajecotries that the rle_id can seperate them. 
test <- posmo |> 
  filter(traj_id==19)

row_index <- which(posmo$datetime == as.POSIXct("2023-04-27 20:42:23", tz="UTC"))
posmo <- posmo |> 
  add_row(.after= row_index)

posmo[row_index+1, "traj"] <- "BREAK"

posmo <- posmo |>
    mutate(traj_id = rle_id(traj))

#because of a stop at coop, trajectories 13 and 15 were split up. These will be recombined in the trajectory 15

posmo$traj_id <- ifelse(posmo$traj_id == 13, 15,posmo$traj_id)

# the same happend for traj_id 33 and 31. Will be comined in traj_id 31

posmo$traj_id <- ifelse(posmo$traj_id == 33, 31,posmo$traj_id)

#The break "trajectories" are not of interest and will be deleted and the real trajectories renumbered 
posmo <- subset(posmo, !grepl("BREAK",traj,ignore.case = T))

posmo <- posmo |>
    mutate(traj_id2 = rle_id(traj_id))

posmo |> 
  ggplot(aes(X,Y))+
  geom_point(aes(color=traj_id2))+
  facet_wrap(~traj_id2)
```

The definition of efficency for this paper is defined by two aspects: 
1. the smallest number of stops per trajectory
2. the shortest distance 

#Results

##Stoplights and roads


##Trajectories split into segments
```{r}
#To be able to compute euclidean distances by hand, we need the coordinates stored in separate columns. The function st_coordinates extracts the coordinates from our sf object. We can bind these coordinates back to our sf object using cbind


posmo_filter <- select(posmo,datetime, X, Y, traj_id2)

posmo_filter <- posmo_filter |> 
  rename(traj_id = traj_id2 )

ggplot(posmo_filter, aes(X,Y, color=datetime))+
  geom_point()

#segmentation
posmo_filter <- posmo_filter |> 
  mutate(steplength = sqrt((lead(X)-X)^2 +(lead(Y)-Y)^2))

posmo_filter <-posmo_filter |>
  group_by(traj_id) |> 
  mutate(
    n_plus1 = sqrt((lead(X,1)-X)^2 +(lead(Y,1)-Y)^2),
    n_plus2 = sqrt((lead(X,2)-X)^2 +(lead(Y,2)-Y)^2),
    n_minus1 = sqrt((lag(X,1)-X)^2 +(lag(Y,1)-Y)^2),
    n_minus2 = sqrt((lag(X,2)-X)^2 +(lag(Y,2)-Y)^2)
    )

#Static and moving
posmo_filter <- posmo_filter |> 
  rowwise() |> 
  mutate(
    stepMean =mean(c(n_minus1, n_minus2, n_plus1, n_plus2))
  ) |> 
      ungroup()

posmo_filter <- posmo_filter |> 
  group_by(traj_id) |> 
  mutate(
    traj_mean = mean(stepMean, na.rm = TRUE),
    static = stepMean < traj_mean
    ) 

#posmo_static <- posmo_filter |>
    #ungroup() |>
    #mutate(static = stepMean < mean(stepMean, na.rm = TRUE))

posmo_static <- posmo_filter |>    
    filter(static)   

#visualizing segment trajectories
posmo_filter |> 
  mutate(static =stepMean < mean(stepMean, na.rm =TRUE)) |> 
  ggplot(aes(X,Y))+
  geom_path()+
  geom_point(aes(color=static))+
  coord_fixed()

#indexing the trajectories
posmo_filter <- posmo_filter |>
    mutate(segment_id = rle_id(static))

#all of it 
posmo_filter |> 
  ggplot(aes(X,Y))+
  geom_point(aes(color=segment_id))+
  geom_path()+
  coord_fixed()

# only the moving data
posmo_filter |> 
  filter(!static) |> 
  ggplot(aes(X,Y))+
  geom_point(aes(color=segment_id))+
  coord_fixed()
```

##DELTE? - Duration of the segments  
```{r}
#needed? 

#Calculating the duration of intervals and grouping them by segment ID
posmo_filter <- posmo_filter |> 
  mutate(duration= datetime-lag(datetime))

posmo_filter |> 
  group_by(segment_id) |> 
  summarize( segment_duration= sum(duration))

# Now I want to cut out the segments which are shorter than 1min / 60s
delete<- posmo_filter |> 
  group_by(segment_id) |> 
  summarize( segment_duration= sum(duration)) |> 
  filter(segment_duration > 60) 

posmo_1min <- posmo_filter[(posmo_filter$segment_id %in% delete$segment_id),]

# Moving data which is longer than 1min

posmo_1min|> 
  filter(!static) |> 
  ggplot(aes(X,Y))+
  geom_point(aes(color=segment_id))+
  coord_fixed()

```

## Creating the different subtrajectories of the trip
```{r}
#Splitting the trajectory into different parts according to bottlenecks
A_part <- posmo_filter |> 
  filter(X <= 2682400) |> 
  filter(Y > 1245454.8177882368) |> 
  select(datetime,X,Y,traj_id,geometry,segment_id,static)

B_part <- posmo_filter |> 
  filter(X > 2682400) |> 
  filter(X <= 2683450)|> 
  select(datetime,X,Y,traj_id,geometry,segment_id,static)

C_part <- posmo_filter |> 
  filter(X > 2683450) |> 
  select(datetime,X,Y,traj_id,geometry,segment_id,static)

#Visualizing the different subtrajectories and checking individual trajectories for anomalies
A_part |> 
  filter(static ==F) |>
  ggplot(aes(X,Y))+
  geom_point(aes(color=traj_id))+ 
  facet_wrap(~traj_id)

posmo_filter |> 
  filter(traj_id==5) |> 
  mapview()
```

##Similarity and groupping of trajectories
```{r}
#Checking for overlaps between the trajectories
 library(igraph)

A_part_lines <- A_part |> 
  group_by(traj_id) |> 
  summarise(do_union = FALSE) |> 
  st_cast("LINESTRING") 

A_part_lines_buff <- A_part_lines |> 
  st_buffer(50)

A_n_traj <- nrow(A_part_lines_buff)
A_mymat <- matrix(nrow = A_n_traj, ncol = A_n_traj)

for (i in 1:A_n_traj) {
  for (j in 1:A_n_traj) {
    if (i == j) {
      A_mymat[i, j] <- NA
    } else {
      inter <- st_intersection(A_part_lines_buff[i, ], A_part_lines_buff[j, ])
      A_mymat[i, j] <- as.numeric(st_area(inter)) / as.numeric(st_area(A_part_lines_buff[i, ]))
    }
  }
}

traj_group <- graph_from_adjacency_matrix(A_mymat> 0.8, mode = "undirected", weighted = TRUE, diag = FALSE)
plot(traj_group)

group_ids <- clusters(traj_group)$membership

A_part_lines$group_id<-group_ids

A_part <- left_join(A_part,st_drop_geometry(A_part_lines), by="traj_id")

#B_Part

B_part_lines <- B_part |> 
  group_by(traj_id) |> 
  summarise(do_union = FALSE) |> 
  st_cast("LINESTRING") 

B_part_lines_buff <- B_part_lines |> 
  st_buffer(50)

B_n_traj <- nrow(B_part_lines_buff)
B_mymat <- matrix(nrow = B_n_traj, ncol = B_n_traj)

for (i in 1:B_n_traj) {
  for (j in 1:B_n_traj) {
    if (i == j) {
      B_mymat[i, j] <- NA
    } else {
      inter <- st_intersection(B_part_lines_buff[i, ], B_part_lines_buff[j, ])
      B_mymat[i, j] <- as.numeric(st_area(inter)) / as.numeric(st_area(B_part_lines_buff[i, ]))
    }
  }
}

traj_group <- graph_from_adjacency_matrix(B_mymat> 0.8, mode = "undirected", weighted = TRUE, diag = FALSE)
plot(traj_group)

group_ids <- clusters(traj_group)$membership

B_part_lines$group_id<-group_ids

B_part <- left_join(B_part,st_drop_geometry(B_part_lines), by="traj_id")

#C_Part

C_part_lines <- C_part |> 
  group_by(traj_id) |> 
  summarise(do_union = FALSE) |> 
  st_cast("LINESTRING") 

C_part_lines_buff <- C_part_lines |> 
  st_buffer(50)

C_n_traj <- nrow(C_part_lines_buff)
C_mymat <- matrix(nrow = C_n_traj, ncol = C_n_traj)

for (i in 1:C_n_traj) {
  for (j in 1:C_n_traj) {
    if (i == j) {
      C_mymat[i, j] <- NA
    } else {
      inter <- st_intersection(C_part_lines_buff[i, ], C_part_lines_buff[j, ])
      C_mymat[i, j] <- as.numeric(st_area(inter)) / as.numeric(st_area(C_part_lines_buff[i, ]))
    }
  }
}

traj_group <- graph_from_adjacency_matrix(C_mymat> 0.8, mode = "undirected", weighted = TRUE, diag = FALSE)
plot(traj_group)

group_ids <- clusters(traj_group)$membership

C_part_lines$group_id<-group_ids

C_part <- left_join(C_part,st_drop_geometry(C_part_lines), by="traj_id")

#Visualizing it
C_part |> 
  group_by(group_id) |> 
  summarise(do_union = FALSE) |> 
  st_cast("LINESTRING") |> 
  plot()

C_part |> 
  group_by(group_id) |> 
  ggplot(aes(X,Y, color=group_id))+
  geom_path()

```

##Number of stops per subtrajectory
```{r}
# Want to count the number of stops per part per trajectory
A_stop <- A_part |>
  filter(static == T) |> 
  distinct(traj_id, segment_id) |> 
  group_by(traj_id) |> 
  summarize(Stops = n())

B_stop <- B_part |>
  filter(static == T) |> 
  distinct(traj_id, segment_id) |> 
  group_by(traj_id) |> 
  summarize(Stops = n())

C_stop <- C_part |>
  filter(static == T) |> 
  distinct(traj_id, segment_id) |> 
  group_by(traj_id) |> 
  summarize(Stops = n())

C_stop |> 
  ggplot(aes(traj_id, Stops))+
  geom_point()

#Now per group
A_stop_mean <- A_stop |> 
  mutate(group_id = A_part$group_id[match(traj_id, A_part$traj_id)]) |> 
  group_by(group_id) |> 
  summarize(mean_stops = mean(Stops))

B_stop_mean <- B_stop |> 
  mutate(group_id = B_part$group_id[match(traj_id, B_part$traj_id)]) |> 
  group_by(group_id) |> 
  summarize(mean_stops = mean(Stops))

C_stop_mean <- C_stop |> 
  mutate(group_id = C_part$group_id[match(traj_id, C_part$traj_id)]) |> 
  group_by(group_id) |> 
  summarize(mean_stops = mean(Stops))

```

##Length of the subtrajectories
```{r}
#Want to know the length of each trajectory, I have to recompute this to know only the length of the moving segments
A_length<- A_part |> 
  filter(static==F) |> 
  group_by(traj_id) |> 
  mutate(distance = sqrt((lead(X,1)-X)^2 +(lead(Y,1)-Y)^2))|> 
  group_by(traj_id) |> 
  summarize(length = sum(distance, na.rm=T))

B_length<- B_part |> 
  filter(static==F) |> 
  group_by(traj_id) |> 
  mutate(distance = sqrt((lead(X,1)-X)^2 +(lead(Y,1)-Y)^2))|> 
  group_by(traj_id) |> 
  summarize(length = sum(distance, na.rm=T))

C_length<- C_part |> 
  filter(static==F) |> 
  group_by(traj_id) |> 
  mutate(distance = sqrt((lead(X,1)-X)^2 +(lead(Y,1)-Y)^2))|> 
  group_by(traj_id) |> 
  summarize(length = sum(distance, na.rm=T))

A_length |> 
  ggplot(aes(x=traj_id,y=length))+
  geom_point()

#Now per group
A_length_mean <- A_length |> 
  mutate(group_id = A_part$group_id[match(traj_id, A_part$traj_id)]) |> 
  group_by(group_id) |> 
  summarize(mean_length = mean(length))

B_length_mean <- B_length |> 
  mutate(group_id = B_part$group_id[match(traj_id, B_part$traj_id)]) |> 
  group_by(group_id) |> 
  summarize(mean_length = mean(length))

C_length_mean <- C_length |> 
  mutate(group_id = C_part$group_id[match(traj_id, C_part$traj_id)]) |> 
  group_by(group_id) |> 
  summarize(mean_length = mean(length))

A_length_mean |> 
  ggplot(aes(x=group_id,y=mean_length))+
  geom_point()

```




```{r}
##RADIUS







posmo_buffer <- st_buffer(posmo_static, 5)

#st_within
within_buffer <- st_within(lights, posmo_buffer)

# Extract the indices from the list
indices <- unlist(within_buffer)

# Subset the lights dataset using the indices
lights_within_buffer <- lights[indices, ]

lights_within_buffer



# Define the radius  within which a trajectory point should intersect with a traffic light
lights_buffer <- st_buffer(lights, 10)

#st_within
within_buffer <- st_within(posmo, lights_buffer)

# Extract the indices from the list
indices <- unlist(within_buffer)

# Subset the posmo dataset using the indices
posmo_within_buffer <- posmo[indices, ]

posmo_within_buffer
#distances <- st_distance(posmo, lights)

tm_shape(lights_within_buffer) +
  tm_symbols(col = "red", size = 1) +
  tm_shape(posmo_static) +
  tm_symbols(col = "blue", size = 0.5) +
  tm_basemap("OpenStreetMap")

# Filter out the traffic lights that are within the specified radius of any trajectory point


```

Other ways to plot it
```{r}
#coordinates system 
st_crs(posmo$lat_y)
lights <- st_transform(lights, "+proj=longlat +datum=WGS84")
posmo  <- st_transform(posmo, "+proj=longlat +datum=WGS84")

map <- leaflet()
map <- addTiles(map)
map <- addCircleMarkers(map, data = lights_within_buffer, color = "red", radius = 4)
map <-addCircleMarkers(map, data = posmo_static, color = "blue", radius = 3)
map
lights_map <- mapview(lights)

# Create a mapview object for the GPS points
posmo_map <- mapview(posmo)

# Combine the two mapview objects into a single map
combined_map <- lights_map + posmo_map

# View the combined map
combined_map
```


```{r}
#animating stuff
library(gganimate)
library(av)
library(transformr)
library(leaflet)


# Convert posmo points to line segments
posmo_lines <- posmo %>%
  group_by(traj_id2) %>%
  summarize() %>%
  st_cast("LINESTRING")


p <- posmo |> 
  filter(datetime == 2023-04-11) |> 
  ggplot(aes(X, Y)) +
  geom_point(aes(traj_id)) +
  labs(x = "Longitude", y = "Latitude") +
  theme_minimal()

# Animate the trajectory over time
animation <- p +
  transition_time(datetime) +
  ease_aes('linear') +
  shadow_wake(wake_length = 0.5)

anim_save("animation.gif", animation)


```




#Discussion

## Comparison

